# -*- coding: utf-8 -*-
'''
 Save the acoustoelectric field after the diffusion step
 ,the pressure field and the lead field. 
 

Here we read in the real and imaginary results of the diffusion 
simulations and join them together to obtain a sincle complex result. 
We then take the gradient to obtain the E field, put it back into trivial producers, 
and save it out to file so it can be played with in python separately. 

 Author: Jean Rintoul 
 Date: 20th July 2020 
 
 
'''
import s4l_v1 as s4l
import s4l_v1.analysis as analysis
import numpy as np
import subprocess
import sys
import haazLib_v2 as hz

basepath = "C:\\Sim4Life\\Jean\\ati-working\\"
codepath = basepath + "scripts\\"
command = 'python '+ codepath + 'gradientp3.py'
finaldatafile = "ae_data.npz"


sim = s4l.document.AllSimulations['Real_Diffusion']
if sim.HasResults():
	simulation_extractor = sim.Results()
	sensor_extractor = simulation_extractor["Overall Field"]
	real_diffusion_output = sensor_extractor.Outputs["T(x,y,z)"]
	real_diffusion_output.Update()
else: 
	print 'diffusion real sim has no results'

v_real_field = real_diffusion_output.Data.Field(0)

sim = s4l.document.AllSimulations['Imag_Diffusion']
if sim.HasResults():
	simulation_extractor = sim.Results()
	sensor_extractor = simulation_extractor["Overall Field"]
	imag_diffusion_output = sensor_extractor.Outputs["T(x,y,z)"]
	imag_diffusion_output.Update()
else: 
	print 'diffusion real sim has no results'

v_imag_field = imag_diffusion_output.Data.Field(0)	
	
# Now join the real and imaginary parts together, to create a complex potential phi result from the diffusion. 
v_field = v_real_field + 1j*v_imag_field

print (v_field.shape)
# Check if the real and imaginary parts are the same size... 

grid_size = real_diffusion_output.Data.Grid.Dimensions
field_grid_size = (grid_size[0]-1,grid_size[1]-1, grid_size[2]-1) #print field_grid_size # 211,208,158
x_axis = real_diffusion_output.Data.Grid.XAxis
y_axis = real_diffusion_output.Data.Grid.YAxis
z_axis = real_diffusion_output.Data.Grid.ZAxis
v_x = (x_axis[1:]+x_axis[:-1])/2.0
v_y = (y_axis[1:]+y_axis[:-1])/2.0
v_z = (z_axis[1:]+z_axis[:-1])/2.0


v_field_3d = v_field.reshape( grid_size[0]-1,grid_size[1]-1,-1,order='F')
print ('v field shape',v_field.shape,v_field_3d.shape, type(v_field))
print ('potential example value: ',v_field_3d[150,150,116])
print ('v field complete ')

# Now we save this out to file, and then compute the gradient in python3, and read it back into the sim. 
vfile = basepath + "potential_field.npz"
np.savez(vfile, v_field_3d = v_field_3d, x=v_x,y=v_y,z=v_z)

# Now, open a subprocess, but read in npz files, 
# otherwise we are piping too much data(it's tens of Gb if you've got a 
# fine resolution grid for the acoustic sim)
child = subprocess.Popen(command, shell=True, stderr=subprocess.PIPE)
while True:
    out = child.stderr.read(1)
    if out == '' and child.poll() != None:
		# print 'no output or no child'
		break
    if out != '':
		sys.stdout.write(out)
		sys.stdout.flush()
		
print 'External Python 3 Command gradient calculation Complete'

vgrad_data = "vgrad.npz"
data = np.load(vgrad_data)
v_grad = data['v_grad']
grad_p = []

print ('gradient shape',v_grad.shape,type(v_grad))

E_vector = - v_grad

print (E_vector.shape)
# get the magnitude using linalg.norm
E_mag = np.linalg.norm(E_vector,axis = 3) # get the magnitude. 
print (E_mag.shape)
#g_source_3d = E.reshape( grid_size[0]-1,grid_size[1]-1,grid_size[2]-1,order='F')
#print ('g_source_3d',g_source_3d.shape,type(g_source_3d))
V_source_viz = hz.visualizeArray(v_field_3d, v_x, v_y, v_z, unit_name="Potential field",unit="V",name="Acoustoelectric Voltage Field" )

E_source_viz = hz.visualizeArray(E_mag,v_x, v_y, v_z,unit_name="E field",unit="V/m",name="Acoustoelectric E field" )

# Save out both the potential field and the final electric field vector generated by the acoustoelectric effect. 
finaldatafile = basepath + finaldatafile
np.savez(finaldatafile, E = E_vector, phi = v_field_3d, x=v_x,y=v_y,z=v_z)

print 'finished!'